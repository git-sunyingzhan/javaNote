1、增强for
	简化数组或集合的遍历
	格式：
		for(元素的类型 变量名：数组或集合){
			
		}
2、可变参数
	定义方法的时候，不知道参数的个数
	格式：
	修饰符 返回值类型 方法名（数据类型... 变量名）{
		方法体；
	}
	说明：
		1）参数类型一定要相同
		2）变量名：所有参数构成的数组的名称
		3）如果即有可变参数，又有其他参数，可变参数放在后面
tips：Arrays类里面的方法
	static<T> List<T> asList<T... a>：将可变参数作为集合元素，获取一个集合对象
	注意：该方法创建的集合长度不可变
	
3、Queue(队列)
	队列需要满足先进先出的原则
	队列的遍历是一次性的，想要获取队列里面的某个元素，需要先将队列中的该元素之前的所有元素获取到，才能获取该元素
	成员方法
		boolean offer(E e):向队列的末尾添加元素（入队）,可以添加null
		E poll():获取并移除队列的头(出队)
		E peek():获取队列的头
4、Deque（双端队列）
	继承Queue，是队列的一种特殊情况，队列的两端都可以进出。
	当使用双端队列存储元素，如果只从一侧操作，就形成了一种存储模式（先进后出）。
	成员方法
		pop():弹栈,删除最后一个元素
		push(E e):压栈，添加元素
5、Stack（栈）
	继承Vector
	成员方法
		E peek():获取栈顶元素
		pop():弹栈
		push():压栈
6、Set接口
	元素无序，不可重复，继承Collection
7、hashSet
	实现了Set接口，元素无序唯一
	底层是哈希表，集合了数组和链表的优点
	哈希表：就是一个数组，
		在jdk1.8之前，数组里面的元素是链表
		在jdk1.8之后，如果链表元素个数大于8，数组元素为红黑二叉树
	if (e.hash == hash &&((k = e.key) == key || (key != null && key.equals(k)))){
    	不添加元素；
	}else{
		添加元素；
	}
	hash过程：
		1）通过hashcode算出新hash
			hash = e.hashCode()>>>16
		2)定位桶（table的索引值）----导致了元素的无序性
			index = hash&table.length-1		取值0~15,table索引也是0~15
		3)判断该桶是否为空
			为空，直接添加元素
			不为空，判断该元素是否存在，不存在添加
	tips：
		红黑二叉树：趋近于平衡树，查询速度很快。查询叶子节点的最大次数，和最小次数不会超过2倍
		平衡树：左孩子和右孩子相等。
	注意：
		HashSet的add方法底层依赖于hashCode和equals方法，所以类需要重写hashCode和equals方法.所以开发中所有的实体类，都需要
		重写hashCode()、equals()、toString()
8、LinkedHashSet
	继承HashSet，元素有序且唯一的。
	有序是由链表保证的，唯一是由哈希表保证的。
9、TreeSet
	实现了Set接口，元素无序唯一，底层是红黑二叉树
	排序方式：(开发中建议使用第二种排序)
		1）自然排序（元素具有比较性）
			元素对应的类实现Comparable接口，重写CompareTo()方法
		2）比较器排序（集合具有比较性）
			构造方法接收一个比较器Comparator
			TreeSet(Comparator<? super E> som)